<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Selma - Stupid Simple Statically Linked Mapper</title>
    <link rel="stylesheet" href="normalize.min.css">
    <link rel="stylesheet" href="style.css">
    <link rel="shortcut icon" href="favicon.ico">
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.0/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="jquery.js"><\/script>')</script>
    <script src="highlight.js"></script>
    <script>
      setTimeout(function(){
        $('body').addClass('onload');
      }, 0);
    </script>
    <!--[if lt IE 9]>
    <script src="html5shiv.js"></script>
    <![endif]-->
  </head>
  <body>
    <section id="content">
      <h1><a href="http://xebia-france.github.io/selma"><img src="img/logo-v6-medium.png" alt="S3lm4 logo"/></a></h1>
      <p id="tag"><em>S</em>tupid <em>S</em>imple <em>S</em>tatically <em>L</em>inked <em>Ma</em>pper</p>
<p>Selma generates static code to map properties from one bean to another. We <em>K</em>eep <em>I</em>t <em>S</em>tupid <em>S</em>imple: convention over configuration, light footprint, easy ot use, easy to learn, are Selma's roots.
    On one side, Selma is an <em>Annotation Processor</em> that generate Java code to handle the mapping from field to field at <em>compile time</em>.
    On the over side, it is an API to instantiate and invoke the generated Mapper implementation.</p>

<h2 id="why">Why another mapping framework ?</h2>

<p>Existings frameworks massively use reflection API to build dynamicaly the mapper. Well let me see, it's fine !
    In fact, it can be, but the better mapping framework I know is vanilla Java code with it's long list of if conditions. Because performance are far better, and I have total control on the mapping. More over, the static code is refactoring proof, and easy to debug.
    But that is painfull :p. Writing all this code is always my preferred part, almost always since there is sometime more than 3 poor little beans. That's where Selma comes, the idea is simple get advantages of the manual mapping without the pain.</p>


<h2 id="tuto_1_min">The 1 minute tutorial</h2>
<p class="bullet-point">First add Selma to your <em>pom</em></p>

<pre><code>&lt;!-- scope provided because the processor is only needed for the compiler --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;fr.xebia.extras&lt;/groupId&gt;
        &lt;artifactId&gt;selma-processor&lt;/artifactId&gt;
        &lt;version&gt;0.1&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;!-- This is the only real dependency you will have in youre binaries --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;fr.xebia.extras&lt;/groupId&gt;
        &lt;artifactId&gt;selma&lt;/artifactId&gt;
        &lt;version&gt;0.1&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre>


<p><i>There are 2 artifacts</i></p>
<ul>
  <li><em>selma-processor</em> - contains the annotation processor and the code generation part. It should be in a provided scope because we need it only at compilation time.</li>
  <li><em>selma</em> - contains the API to work with the generated mappers. We use the default scope because we need the API at runtime.</li>
</ul>

<p class="bullet-point">Then declare your mapper</p>
<pre><code>@Mapper
public interface SelmaMapper {
    OutBean asOutBean(InBean in);
}
</code></pre>

<p><i>Here we've defined SelmaMapper which maps InBean to an instance of OutBean.</i></p>
<p class="bullet-point">Finally, use the mapper</p>

<pre><code>// Get SelmaMapper
SelmaMapper mapper = Selma.getMapper(SelmaMapper.class);

// Map my InBean
OutBean res = mapper.asOutBean(in);
</code></pre>

<p class="bullet-point">Build and enjoy!</p>
<p>Any issue will be reported in the compiler log, it will also give you fix tips.</p>
<p><a href="https://github.com/xebia-france/selma/tree/master/examples">Check our sample app project in github.</a></p>



    </section>
    <footer>
      <span>© Séven Le Mesle and Xebia 2014</span>
    </footer>
  </body>
</html>